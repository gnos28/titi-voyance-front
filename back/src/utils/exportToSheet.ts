import { GoogleSpreadsheet } from "google-spreadsheet";
import * as dotenv from "dotenv";
import AlphanumericEncoder from "alphanumeric-encoder";

dotenv.config();

type Data = {
  id: number | string;
  [key: string]: string | number | undefined;
};

export const exportToSheet = async (datas: Data[], sheetId: string) => {
  console.log("exportToSheet");

  const { GOOGLE_SERVICE_ACCOUNT_EMAIL, GOOGLE_PRIVATE_KEY, EXPORT_SHEET_ID } =
    process.env;

  // let rawdatas = fs.readFileSync("jobseasons-oauth.json", "utf8");

  // let datas = JSON.parse(rawdatas);

  if (
    GOOGLE_SERVICE_ACCOUNT_EMAIL &&
    GOOGLE_PRIVATE_KEY &&
    EXPORT_SHEET_ID &&
    datas.length > 0
  ) {
    const doc = new GoogleSpreadsheet(EXPORT_SHEET_ID);
    const keys = Object.keys(datas[0]);
    const newIds = datas.map((data) => data.id);

    await doc.useServiceAccountAuth({
      // env var values are copied from service account credentials generated by google
      // see "Authentication" section in docs for more info
      client_email: GOOGLE_SERVICE_ACCOUNT_EMAIL,
      private_key: GOOGLE_PRIVATE_KEY,
    });

    await doc.loadInfo(); // loads document properties and worksheets

    const sheet = doc.sheetsById[sheetId];

    const rows = await sheet.getRows();
    // console.log("rows", rows);

    const previousDatas = rows.map((row) => {
      const previousData: Omit<Data, "id"> = {};
      keys.forEach((key) => (previousData[key] = row[key]));

      return previousData;
    }) as Data[];

    const previousDatasIds = previousDatas.map((data) => data.id);
    const newDatas = datas.filter(
      (data) => !previousDatasIds.includes(data.id)
    );

    const nbNew = newDatas.length;

    const filteredPreviousDatas = previousDatas.filter(
      (data) => !newIds.includes(data.id)
    );

    // sheet.clearRows();

    // const allDatas = [...filteredPreviousDatas, ...datas].sort(
    const allDatas = newDatas.sort((dataA, dataB) => {
      if (dataA.id > dataB.id) {
        return -1;
      }
      if (dataA.id < dataB.id) {
        return 1;
      }
      return 0;
    });

    if (allDatas.length) {
      let nbCols = Object.keys(allDatas[0]).length;

      const encoder = new AlphanumericEncoder();
      const encodedCol = encoder.encode(nbCols);

      sheet.insertDimension(
        "ROWS",
        { startIndex: 1, endIndex: nbNew + 1 },
        false
      );

      await sheet.loadCells(`A2:${encodedCol}${nbNew + 1}`);

      allDatas.map((data, dataIndex) => {
        Object.keys(data).map((col, colIndex) => {
          const cell = sheet.getCell(dataIndex + 1, colIndex);

          if (cell) cell.value = data[col] || "";
        });
      });
      await sheet.saveUpdatedCells();
    }

    return nbNew;
  }
};
